{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>This site is a work in progress.</p>"},{"location":"#quetzal","title":"Quetzal","text":"<p>Quetzal is a tool for managing existing NixOS hosts - basically a fancy wrapper around <code>nix-build</code>, <code>nix copy</code>, <code>nix-env</code>, <code>/nix/store/.../bin/switch-to-configuration</code>, <code>scp</code> and more. Quetzal supports updating multiple hosts in a row, and with support for health checks makes it fairly safe to do so.</p>"},{"location":"#notable-features","title":"Notable features","text":"<ul> <li>multi host support</li> <li>health checks</li> <li>no state</li> </ul>"},{"location":"#installation-and-prerequisites","title":"Installation and prerequisites","text":"<p>Quetzal requires <code>nix</code> (at least v2), <code>ssh</code> and <code>scp</code> to be available on <code>$PATH</code>. It should work on any modern Linux distribution, but NixOS is the only one we test on.</p> <p>Pre-built binaries are not provided, since we install Quetzal through an overlay.</p> <p>The easiest way to get Quetzal up and running is to fork this repository and run <code>nix-build</code>, which should result in a store path containing the Quetzal binary. Consider checking out a specific tag, or at least pin the version of Quetzal you're using somehow.</p>"},{"location":"#using-quetzal","title":"Using Quetzal","text":"<p>All commands support a <code>--help</code> flag; <code>quetzal --help</code> as of v1.0.0: <pre><code>$ quetzal --help\nusage: quetzal [&lt;flags&gt;] &lt;command&gt; [&lt;args&gt; ...]\n\nNixOS host manager\n\nFlags:\n  --help     Show context-sensitive help (also try --help-long and --help-man).\n  --version  Show application version.\n  --dry-run  Don't do anything, just eval and print changes\n\nCommands:\n  help [&lt;command&gt;...]\n    Show help.\n\n  build [&lt;flags&gt;] &lt;deployment&gt;\n    Evaluate and build deployment configuration to the local Nix store\n\n  push [&lt;flags&gt;] &lt;deployment&gt;\n    Build and transfer items from the local Nix store to target machines\n\n  deploy [&lt;flags&gt;] &lt;deployment&gt; &lt;switch-action&gt;\n    Build, push and activate new configuration on machines according to switch-action\n\n  check-health [&lt;flags&gt;] &lt;deployment&gt;\n    Run health checks\n\n  upload-secrets [&lt;flags&gt;] &lt;deployment&gt;\n    Upload secrets\n\n  exec [&lt;flags&gt;] &lt;deployment&gt; &lt;command&gt;...\n    Execute arbitrary commands on machines\n</code></pre></p> <p>Notably, <code>quetzal deploy</code> requires a <code>&lt;switch-action&gt;</code>. The switch-action must be one of <code>dry-activate</code>, <code>test</code>, <code>switch</code> or <code>boot</code> corresponding to <code>nixos-rebuild</code> arguments of the same name. Refer to the NixOS manual for a detailed description of switch-actions.</p> <p>For help on this and other commands, run <code>quetzal &lt;cmd&gt; --help</code>.</p> <p>Example deployments can be found in the <code>examples</code> directory, and built as follows: <pre><code>$ quetzal build examples/simple.nix\nSelected 2/2 hosts (name filter:-0, limits:-0):\n      0: db01 (secrets: 0, health checks: 0)\n      1: web01 (secrets: 0, health checks: 0)\n\n&lt;probably lots of nix-build output&gt;\n\n/nix/store/grvny5ga2i6jdxjjbh2ipdz7h50swi1n-quetzal\nnix result path:\n/nix/store/grvny5ga2i6jdxjjbh2ipdz7h50swi1n-quetzal\n</code></pre></p> <p>The result path is written twice, which is a bit silly, but the reason is that only the result path is written to stdout, and everything else (including <code>nix-build</code> output) is redirected to stderr. This makes it easy to use Quetzal for scripting, e.g. if one want to build using Quetzal and then <code>nix copy</code> the result path somewhere else.</p> <p>Note that <code>examples/simple.nix</code> contain two different hosts definitions, and a lot of copy paste. All the usual nix tricks can of course be used to avoid duplication.</p> <p>Hosts can be deployed with the <code>deploy</code> command as follows: <code>quetzal deploy examples/simple.nix</code> (this will fail without modifying <code>examples/simple.nix</code>).</p>"},{"location":"#selectingfiltering-hosts-to-build-and-deploy","title":"Selecting/filtering hosts to build and deploy","text":"<p>All hosts defined in a deployment file is returned to Quetzal as a list of hosts, which can be manipulated with the following flags:</p> <ul> <li><code>--on glob</code> can be used to select hosts by name, with support for glob patterns</li> <li><code>--limit n</code> puts an upper limit on the number of hosts</li> <li><code>--skip n</code> ignore the first <code>n</code> hosts</li> <li><code>--every n</code> selects every n'th host, useful for e.g. selecting all even (or odd) numbered hosts</li> </ul> <p>(all relevant commands should already support these flags.)</p> <p>The ordering currently can't be changed, but should be deterministic because of nix.</p> <p>Most commands output a header like this: <pre><code>Selected 4/17 hosts (name filter:-6, limits:-7):\n      0: foo-p02 (secrets: 0, health checks: 1)\n      1: foo-p05 (secrets: 0, health checks: 1)\n      2: foo-p08 (secrets: 0, health checks: 1)\n      3: foo-p11 (secrets: 0, health checks: 1)\n</code></pre></p> <p>The output is pretty self explanatory, except probably for the last bit of the first line. <code>name filter</code> shows the change in number of hosts after glob matching on the hosts name, and <code>limits</code> shows the change after applying <code>--limit</code>, <code>--skip</code> and <code>--every</code>.</p>"},{"location":"#tagging-hosts","title":"Tagging hosts","text":"<p>Each host can be tagged with an arbitrary amount of tags, which can be used to select and sort hosts.</p> <p>To tag a host, use the <code>deployment.tags</code> option, e.g. <code>deployment.tags = [ \"prod\" \"master\" \"rack-17\" ]</code>. Hosts can now be selected with the <code>--tagged</code> option, e.g.<code>--tagged=\"prod,master\"</code> will only select hosts tagged both <code>prod</code> and <code>master</code>.</p> <p>To sort hosts based on tags, use the <code>network.ordering.tags</code> option, e.g. <code>network.ordering.tags = [ \"master\" \"slave\"]</code>. This ordering can be changed at runtime using the <code>--order-by-tags</code> option, eg. <code>--order-by-tags=\"slave,master\"</code> (this also works when <code>network.ordering.tags</code> isn't defined). Hosts without matching tags will end up at the end of the list.</p>"},{"location":"#environment-variables","title":"Environment Variables","text":"<p>Quetzal supports the following (optional) environment variables:</p> <ul> <li><code>SSH_IDENTITY_FILE</code> the (local) path to the SSH private key file that should be used</li> <li><code>SSH_USER</code> specifies the user that should be used to connect to the remote system</li> <li><code>SSH_SKIP_HOST_KEY_CHECK</code> if set disables host key verification</li> <li><code>SSH_CONFIG_FILE</code> allows to change the location of the ~/.ssh/config file</li> <li><code>QUETZAL_NIX_EVAL_CMD</code> Quetzal will invoke this command instead of default: \"nix-instantiate\" on PATH </li> <li><code>QUETZAL_NIX_BUILD_CMD</code> Quetzal will invoke this command instead of default: \"nix-build\" on PATH </li> <li><code>QUETZAL_NIX_SHELL_CMD</code> Quetzal will invoke this command instead of default: \"nix-shell\" on PATH</li> <li><code>QUETZAL_NIX_EVAL_MACHINES</code> path to a custom eval-machines.nix. Defaults to the eval-machines.nix bundled with Quetzal</li> </ul>"},{"location":"#secrets","title":"Secrets","text":"<p>Files can be uploaded without ever ending up in the nix store, by specifying each file as a secret. This will use scp for copying a local file to the remote host.</p> <p>See <code>examples/secrets.nix</code> or the type definitions in <code>data/options.nix</code>.</p> <p>To upload secrets, use the <code>quetzal upload-secrets</code> subcommand, or pass <code>--upload-secrets</code> to <code>quetzal deploy</code>.</p> <p>Note: Quetzal will automatically create directories parent to <code>secret.Destination</code> if they don't exist. New dirs will be owned by root:root and have mode 755 (drwxr-xr-x). Automatic directory creation can be disabled by setting <code>secret.mkDirs = false</code>.</p>"},{"location":"#health-checks","title":"Health checks","text":"<p>Quetzal has support for two types of health checks:</p> <ul> <li>command based health checks, which are run on the target host (success defined as exit code == 0)</li> <li>HTTP based health checks, which are run from the host Quetzal is running on (success defined as HTTP response codes in the 2xx range)</li> </ul> <p>See <code>examples/healthchecks.nix</code> for an example.</p> <p>There are no guarantees about the order health checks are run in, so if you need something complex you should write a script for it (e.g. using <code>pkgs.writeScript</code>). Health checks will be repeated until success, and the interval can be configured with the <code>period</code> option (see <code>data/options.nix</code> for details).</p> <p>It is currently possible to have expressions like <code>\"test \\\"$(systemctl list-units --failed --no-legend --no-pager |wc -l)\\\" -eq 0\"</code> (count number of failed systemd units, fail if non-zero) as the first argument in a cmd-healthcheck. This works, but is discouraged, and might break at any time.</p>"},{"location":"#pre-deploy-checks-experimental","title":"Pre-deploy checks (experimental)","text":"<p>Quetzal supports running checks before changing the target host (note: files will still be pushed to the host). These checks work exactly like health checks, which means they will run forever until they have all succeeded. This is an experimental feature that is very likely to change in the future. Comments and feedback welcome :).</p> <p>Pre-deploy checks can be defined using <code>deployment.preDeployChecks</code>.</p>"},{"location":"#advanced-configuration","title":"Advanced configuration","text":"<p>nix.conf-options: The \"network\"-attrset supports a sub-attrset named \"nixConfig\". Options configured here will pass <code>--option &lt;name&gt; &lt;value&gt;</code> to all nix commands. Note: these options apply to an entire deployment and are not configurable on per-host basis. The default is an empty set, meaning that the nix configuration is inherited from the build environment. See <code>man nix.conf</code>.</p> <p>network.buildShell By passing <code>--allow-build-shell</code> and setting <code>network.buildShell</code> to a nix-shell compatible derivation (eg. <code>pkgs.mkShell ...</code>), it's possible to make Quetzal execute builds from within the defined shell. This makes it possible to have arbitrary dependencies available during the build, say for use with nix build hooks. Be aware that the shell can potentially execute any command on the local system.</p> <p>special deployment options:</p> <p>(per-host granularity)</p> <p><code>buildOnly</code> makes Quetzal skip the \"push\" and \"switch\" steps for the given host, even if \"quetzal deploy\" or \"quetzal push\" is executed. (default: false)</p> <p><code>substituteOnDestination</code> Sets the <code>--substitute-on-destination</code> flag on nix copy, allowing for the deployment target to use substitutes. See <code>nix copy --help</code>. (default: false)</p> <p>Example usage of <code>nixConfig</code> and deployment module options: <pre><code>network = {\n    nixConfig = {\n        \"extra-sandbox-paths\" = \"/foo/bar\";\n    };\n};\n\nmachine1 = { ... }: {\n    deployment.buildOnly = true;\n};\n\nmachine2 = { ... }: {\n    deployment.substituteOnDestination = true;\n};\n</code></pre></p> <p>mutually recursive configurations Each host's configuration has access to a <code>nodes</code> argument, which contains the compiled configurations of all hosts.</p> <pre><code>machine1 = { nodes, ... }: {\n    hostnames.machine2 = \n        (builtins.head nodes.machine2.networking.interfaces.foo.ipv4.addresses).address;\n    networking.interfaces.foo.ipv4.addresses = [\n        {\n            address = \"10.0.0.10\";\n            prefixLength = 32;\n        }\n    ];\n}\n\nmachine2 = { nodes, ... }: {\n    hostnames.machine1 = \n        (builtins.head nodes.machine1.networking.interfaces.foo.ipv4.addresses).address;\n    networking.interfaces.foo.ipv4.addresses = [\n        {\n            address = \"10.0.0.20\";\n            prefixLength = 32;\n        }\n    ];\n}\n</code></pre>"},{"location":"#hacking-quetzal","title":"Hacking Quetzal","text":"<p>All commands mentioned below is available in the nix-shell, if you run <code>nix-shell</code> with working dir = project root. The included <code>shell.nix</code> uses the latest <code>nixos-unstable</code> from GitHub by default, but you can override this by passing in another, eg. <code>nix-shell --arg nixpkgs '&lt;nixpkgs&gt;'</code> for your <code>$NIX_PATH</code> nixpkgs.</p>"},{"location":"#go-dependency-management","title":"Go dependency management","text":"<p>From within <code>nix-shell</code>, <code>go get -u</code> updates all go modules. Remember to update the <code>vendorSha256</code> in <code>./default.nix</code></p>"},{"location":"#building-the-project-with-pinned-dependencies","title":"Building the project with pinned dependencies","text":"<p>$ <code>nix-build --arg nixpkgs \"builtins.fetchTarball https://github.com/NixOS/nixpkgs/archive/&lt;rev&gt;.tar.gz\"</code></p>"},{"location":"#about-the-project","title":"About the project","text":"<p>We needed a tool for managing our NixOS servers, and ended up writing one ourself. This is it. We use it on a daily basis to build and deploy our NixOS fleet, and when we need a feature we add it.</p> <p>Quetzal is by no means done. The CLI UI might (and probably will) change once in a while. The code is written by humans with an itch to scratch, and we're discussing a complete rewrite (so feel free to complain about the source code since we don't like it either). It probably wont accidentally switch your local machine, so you should totally try it out, but do consider pinning to a specific git revision.</p>"},{"location":"differences-from-morph/","title":"Differences from morph","text":""},{"location":"examples/","title":"Deployment examples","text":""},{"location":"examples/#simple","title":"Simple","text":"<pre><code>let\n  pkgs = import (import ../nixpkgs.nix) { };\nin\n{\n  network = {\n    inherit pkgs;\n    specialArgs = {\n      systemdBoot = true;\n    };\n    description = \"simple hosts\";\n    ordering = {\n      tags = [\n        \"db\"\n        \"web\"\n      ];\n    };\n  };\n\n  \"web01\" =\n    { systemdBoot, ... }:\n    {\n      deployment.tags = [ \"web\" ];\n\n      boot.loader.systemd-boot.enable = systemdBoot;\n      boot.loader.efi.canTouchEfiVariables = true;\n\n      services.nginx.enable = true;\n\n      fileSystems = {\n        \"/\" = {\n          label = \"nixos\";\n          fsType = \"ext4\";\n        };\n        \"/boot\" = {\n          label = \"boot\";\n          fsType = \"vfat\";\n        };\n      };\n    };\n\n  \"db01\" = _: {\n    deployment.tags = [ \"db\" ];\n\n    boot.loader.systemd-boot.enable = true;\n    boot.loader.efi.canTouchEfiVariables = true;\n\n    services.postgresql.enable = true;\n\n    fileSystems = {\n      \"/\" = {\n        label = \"nixos\";\n        fsType = \"ext4\";\n      };\n      \"/boot\" = {\n        label = \"boot\";\n        fsType = \"vfat\";\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"examples/#health-checks","title":"Health checks","text":"<pre><code>let\n  pkgs = import (import ../nixpkgs.nix) { };\nin\n{\n  network = {\n    inherit pkgs;\n    description = \"health check demo hosts\";\n  };\n\n  \"web01\" = _: {\n    boot.loader.systemd-boot.enable = true;\n    boot.loader.efi.canTouchEfiVariables = true;\n\n    services.nginx.enable = true;\n\n    fileSystems = {\n      \"/\" = {\n        label = \"nixos\";\n        fsType = \"ext4\";\n      };\n      \"/boot\" = {\n        label = \"boot\";\n        fsType = \"vfat\";\n      };\n    };\n\n    deployment = {\n      healthChecks = {\n        cmd = [\n          {\n            cmd = [\n              \"true\"\n              \"one argument\"\n              \"another argument\"\n            ];\n            description = \"Testing that 'true' works.\";\n          }\n        ];\n\n        http = [\n          {\n            scheme = \"http\";\n            port = 80;\n            path = \"/\";\n            description = \"Check whether nginx is running.\";\n            period = 1; # number of seconds between retries\n          }\n          {\n            scheme = \"https\";\n            port = 443;\n            host = \"some-other-host.example.com\"; # defaults to the hostname of the host if unset\n            path = \"/health\";\n            description = \"Check whether $imaginaryService is running.\";\n          }\n        ];\n      };\n\n      preDeployChecks = {\n        # Works exactly like health checks\n        # Have you read the warning about this feature in the README?\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"examples/#secrets","title":"Secrets","text":"<pre><code>let\n  pkgs = import (import ../nixpkgs.nix) { };\nin\n{\n  network = {\n    inherit pkgs;\n    description = \"webserver with secrets\";\n  };\n\n  \"web01\" = _: {\n    deployment = {\n      secrets = {\n        \"nix-cache-signing-key\" = {\n          source = \"../secrets/very-secret.txt\";\n          destination = \"/var/secrets/very-secret.txt\";\n          owner.user = \"nginx\";\n          owner.group = \"root\";\n          permissions = \"0400\"; # this is the default\n          action = [\n            \"sudo\"\n            \"systemctl\"\n            \"reload\"\n            \"nginx.service\"\n          ];\n        };\n      };\n    };\n\n    boot.loader.systemd-boot.enable = true;\n    boot.loader.efi.canTouchEfiVariables = true;\n\n    services.nginx.enable = true;\n\n    fileSystems = {\n      \"/\" = {\n        label = \"nixos\";\n        fsType = \"ext4\";\n      };\n      \"/boot\" = {\n        label = \"boot\";\n        fsType = \"vfat\";\n      };\n    };\n  };\n}\n</code></pre>"}]}